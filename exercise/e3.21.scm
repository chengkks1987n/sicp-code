;;; exercise 3.21

(define	(front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))

(define (empty-queue? queue) (null? (front-ptr queue)))

(define (make-queue) (cons '() '()))

(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (car (front-ptr queue))))

(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
	   (set-front-ptr! queue new-pair)
	   (set-rear-ptr! queue new-pair)
	   queue)
	  (else
	   (set-cdr! (rear-ptr queue) new-pair)
	   (set-rear-ptr! queue new-pair)
	   queue))))

(define (delete-queue! queue)
  (cond ((empty-queue? queue)
	 (error "DELETE! called with an empty queue" queue))
	(else
	 (set-front-ptr! queue (cdr (front-ptr queue)))
	 queue)))

(define (print-queue q)
  (front-ptr q))

(define q1 (make-queue))
(print-queue q1)
(insert-queue! q1 'a)
(print-queue q1)
(insert-queue! q1 'b)
(print-queue q1)
(delete-queue! q1)
(print-queue q1)
(delete-queue! q1)
(print-queue q1)

;;; exercise 3.22
(define (make-queue)
(let ((front-ptr (list))
      (rear-ptr (list)))
  (define (empty?) (null? front-ptr))
  (define (front)
    (cond ((empty?)
	   (error "queue is empty!"))
	  (else (car front-ptr))))
  (define (insert! item)
    (let ((new-value (list item)))
      (cond ((empty?)
	     (set! front-ptr new-value)
	     (set! rear-ptr new-value)
	     front-ptr)
	    (else
	     (set-cdr! rear-ptr new-value)
	     (set! rear-ptr (cdr rear-ptr))
	     front-ptr))))
  (define (delete!)
    (cond ((empty?)
	   (error "queue is empty!"))
	  (else (set! front-ptr (cdr front-ptr))
		front-ptr)))
  (define (dispatch m)
    (cond ((eq? m 'empty-queue?) (empty?))
	  ((eq? m 'front-queue) (front))
	  ((eq? m 'insert-queue!) insert!)
	  ((eq? m 'delete-queue!) (delete!))
	  ((eq? m 'print-queue) front-ptr)
	  (else (error "undefine message"))))
  dispatch))

(define (empty-queue? q) (q 'empty-queue?))
(define (front-queue q) (q 'front-queue))
(define (print-queue q) (q 'print-queue))
(define (insert-queue! q item) ((q 'insert-queue!) item))
(define (delete-queue! q) (q 'delete-queue!))

(define q1 (make-queue))
(print-queue q1)
(insert-queue! q1 'a)
(print-queue q1)
(insert-queue! q1 'b)
(print-queue q1)
(front-queue q1)
(delete-queue! q1)
(print-queue q1)
(delete-queue! q1)
(print-queue q1)

;;;exercise 3.23
(define (make-deque) (cons '() '()))

(define (front-ptr q) (car q))
(define (rear-ptr q) (cdr q))
(define (set-front-ptr! q v) (set-car! q v))
(define (set-rear-ptr! q v) (set-cdr! q v))

(define (make-node item pre next) (cons item (cons pre next)))
(define (node-value node) (car node))
(define (pre-node node) (car (cdr node)))
(define (next-node node) (cdr (cdr node)))
(define (set-pre-node! node v) (set-car! (cdr node) v)) 
(define (set-next-node! node v) (set-cdr! (cdr node) v))

(define (empty-deque? q) (null? (front-ptr q)))
(define (front-insert-deque! q item)
  (let ((new-value (make-node item '() '())))
    (cond ((empty-deque? q)
	   (set-front-ptr! q new-value)
	   (set-rear-ptr! q new-value))
	  (else (set-next-node! new-value (front-ptr q))
		(set-pre-node! (front-ptr q) new-value)
		(set-front-ptr! q new-value)))))
(define (rear-insert-deque! q item)
  (let ((new-value (make-node item '() '())))
    (cond ((empty-deque? q)
	   (set-front-ptr! q new-value)
	   (set-rear-ptr! q new-value))
	  (else (set-pre-node! new-value (rear-ptr q))
		(set-next-node! (rear-ptr q) new-value)
		(set-rear-ptr! q new-value)))))

(define (front-delete-deque! q)
  (cond ((empty-deque? q) (error "deque is empty!"))
	(else (set-front-ptr! q (next-node (front-ptr q)))
	      (if (null? (front-ptr q))
		  (set-rear-ptr! q '())
		  (set-pre-node! (front-ptr q) '())))))
(define (rear-delete-deque! q)
  (cond ((empty-deque? q) (error "deque is empty!"))
	(else (set-rear-ptr! q (pre-node (rear-ptr q)))
	      (if (null? (rear-ptr q))
		  (set-front-ptr! q '())
		  (set-next-node! (rear-ptr q) '())))))

(define (front-deque q)
  (if (empty-deque? q)
      (error "empty!")
      (car (front-ptr q))))
(define (rear-deque q) 
  (if (empty-deque? q)
      (error "empty!")
      (car (rear-ptr q))))
(define (front-print-deque q)
  (define (iter node)
    (if (null? node)
	(newline)
	(begin (display (node-value node))
	       (display " ")
	       (iter (next-node node)))))
  (iter (front-ptr q)))
(define (rear-print-deque q)
  (define (iter node)
    (if (null? node)
	(newline)
	(begin (display (node-value node))
	       (display " ")
	       (iter (pre-node node)))))
  (iter (rear-ptr q)))		    
;; test cases
(define q (make-deque))

(front-deque q)
(rear-deque q)
(front-print-deque q)
(rear-print-deque q)

(front-insert-deque! q 'a)

(front-insert-deque! q 'b)

(rear-insert-deque! q 'c)

(rear-insert-deque! q 'd)

(rear-delete-deque! q)

(front-delete-deque! q)
